---
id: '11'
title: 11. API 리팩터링
---

## 11.1 질의 함수와 변경 함수 분리하기

<details>

```java
// before
public long getTotalOutstandingAndSendBill() {
  long result = customer.getInvoices()
      .stream()
      .mapToLong(Invoice::getAmount)
      .sum();
  emailGateway.send(formatBill(customer));
  return result
}

// after
public long getTotalOutstanding() {
  return customer.getInvoices()
      .stream()
      .mapToLong(Invoice::getAmount)
      .sum();
}

public void sendBill() {
  emailGateway.send(formatBill(customer));
}
```

- 겉보기 부수효과(observable side effect)가 전혀 없이 값을 반환해주는 함수를 추구해야 함
  - 겉보기 부수효과: 데이터 값이 변경되는 것, 외부로 입출력이 있는 것
  - 언제 어디서든 호출되도 문제가 없음
  - 명령-질의 분리(command-query separation) 라고도 함

</details>

## 11.2 매개 변수화하기

<details>

```java
// before
public void raiseSalaryTenPercent() {
  this.salary = this.salary.multiply(1.1);
}
public void raiseSalaryFivePercent() {
  this.salary = this.salary.multiply(1.05);
}

// after
public void raiseSalary(double factor) {
  this.salary = this.salary.multiply(factor);
}
```

- 리터럴 값만 다른 함수가 있다면 매개변수화 해서 함수의 재사용성을 늘리는 전략

</details>

## 11.3 플래그 인수 제거하기

<details>

```java
// before
public void setDimension(String name, double value) {
  if (name.equals("height")) {
    this.height = value;
    return;
  }
  if (name.equals("width")) {
    this.width =  value;
    return;
  }
}

// after
public void setHeight(double value) {
  this.height = value;
}
public void setWidth(double value) {
  this.width = value;
}
```

- 인자에 boolean, enum, string이 들어가면 의심해 볼 수 있음
- 플래그 인수는 호출 할 수 있는 함수가 무엇이고 어떻게 해야하는지 파악이 어려워짐
- 플래그 인수가 둘 이상이면 함수 하나가 너무 많은 일을 하고 있다는 신호

</details>

## 11.4 객체 통째로 넘기기

<details>

```java
// before
double low = room.getDaysTempRange().getLow();
double high = room.getDaysTempRange().getHigh();
if (plain.withinRange(low, high))

// after
if (plain.withinRange(room.getDaysTempRange()))
```

- 객체를 통째로 넘기면 좋은점
  - 변화에 대응하기 쉬움 (함수에 인자가 더 필요하면 객체에 담을 수 있음)
  - 가독성 증가
  - 로직 중복 제거
- 함수가 레코드(객체)에 의존하기를 원치 않을땐 X
- 객체의 일부를 꺼내 그것으로 무엇을 하는 로직이 있다면, 이는 해당 객체에 메소드화 할 수 있다는 신호

</details>

## 11.5 매개변수를 질의 함수로 바꾸기

<details>

```java
// before
availableVacation(employee, employee.getGrade());
public boolean availableVacation(Employee employee, Grade grade) {...}

// after
availableVacation(employee);
public boolean availableVacation(Employee employee) {
  Grade grade = employee.getGrade(); // 매개변수를 질의함수로 바꾼 부분
  ...
}
```

- 매개변수 목록은
  - 중복을 피하는게 좋음
  - 짧을수록 좋음
- 저자는 호출하는 쪽을 간소화하고, 피호출 함수에 책임을 지게 만드는 구조를 주로 다룸
  - 물론 해당 클래스가 그정도의 책임을 가져도 될 경우에만!
  - 그래서 해당 리팩터링 시, 피호출자(리팩터링 대상)의 클래스가 과도한 의존성을 지니게 된다면 주의해야 함
- 리팩터링 대상 함수는 참조 투명해야 함
  - 참조 투명: 똑같은 값에 항상 같은 결과 -> 해당 함수가 가변 전역 변수를 이용하는 일이 없어야 함

</details>

## 11.6 질의 함수를 매개변수로 바꾸기

<details>

- 11.5 와 반대되는 리팩터링
- 클래스 설계 시 책임의 소재에 따라 달라질수 있는 문제
- 매개변수 객체가 참조 투명하지 않다면 해당 함수도 참조 투명하지 않음
  - 이때 해당 리팩터링 적용 가능
- 단점은 호출자가 매개변수로 어떤 값을 보내야 할 지 알아야 함
  - 결국 설계실력을 닦아야 하는 문제로 귀결
- 자바스크립트, 파이썬 등의 일부 언어에서는 객체 안에 데이터를 직접 얻어 낼 수 있는 방법이 항상 존재 하지만,
  - 해당 클래스는 불변용으로 설계한 것을 알리는 것만으로도 좋은 효과를 누릴 수 있음

</details>