---
id: 02-destroy-create-object
title: 02. 객체 생성과 파괴
---

## 주요 포인트

- 올바른 객체 생성 시기와 생성 법
- 불필요한 객체 생성을 피하는 법
- 제때 파괴됨을 보장하는 법
- 파괴 전 정리 작업 관리하는 법

## Item 01. 생성자 대신 정적 팩터리 메서드를 고려하라

> Factory Method 패턴과는 다른 이야기임

- 클래스 생성자와는 별도로, 정적 팩터리 메소드 (Static Factory Method)로 객체 생성을 관리할 수 있음
- 정적 팩터리 메소드로 제공하는 것은 장단점이 존재하므로 무조건 사용하라는 것은 아님

### 일반 생성자보다 정적 팩터리 메소드가 좋은 이유

#### 1) 이름을 가질 수 있음

- 정적 팩터리 메소드를 잘지어 생성되는 의미를 더욱 상세하게 묘사할 수 있음
- `BigInteger(int, int, Random)` vs `BigInteger.probablePrime()`
  - 후자가 설명력이 더 강함

#### 2) 호출될때 마다 인스턴스를 새로 생성하지 않아도 됨

- 불변 클래스는 인턴스를 미리 만드는 캐싱 전략으로 재활용 가능
- `Boolean(boolean)` vs `Boolean.valueOf(boolean)`
  - 후자는 구현이 미리 만들어 놓은 객체를 리턴

#### 3) 반환 타입의 하위 타입 객체를 반환할 수 있는 능력을 가짐

> 논의하면 좋을 내용 일 듯, 아래는 나만의 해석

- 코드의 유연성을 제공함
- 하위의 클래스가 어떤건지 상관없이 상위 타입의 인터페이스로 개발이 가능함
  - 하위 타입을 신경쓰지 않아도 되서, 개발자가 해당 API를 통해 알아야할 내용을 줄일 수 있음

#### 4) 입력 매개변수에 따라 다른 클래스의 객체를 반환할 수 있음

- 예시: `EnumSet` 클래스는 정적 팩터리만 제공
  - 원소 수에따라 `RegularEnumSet` 혹은 `JumboEnumSet` 중 하나를 반환

#### 5) 정적 팩터리 메서드를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않아도 됨

> 이게 왜 장점?

- 예시: JDBC
  - JDBC 코드 구성
    - Service Interface: 구현체 동작 정의
    - Provider Registration API: 구현체 등록용
    - Service Access API: 클라이언트 전용
  - 클라이언트가 Service Acess API 를 통해 Provider 조건 명시가능
  - Service Access API가 정적 팩터리 메서드를 이용하여 Provider를 유연하게 심어줄 수 있음

### 정적 팩터리 메소드의 단점

#### 1) 정적 팩터리 메소드만 구성된 클래스는 하위 클래스를 만들 수 없음

- 상속을 하려면 public, protected 생성자가 필요함
- 상속보다 컴포지션을 이용하는 전략으로는 장점으로 전락할 수도 있음

#### 2) 정적 팩터리 메서드는 프로그래머가 찾기 어려움

- API 문서를 잘 써놓고 메서드의 이름도 널리 알려진 규약을 따를 수 밖에 없음

### 정적 팩터리 메소드에 쓰이는 잘알려진 컨벤션

- `from`: 매개 변수 하나를 받아 해당 타입의 인스턴스 반환
- `of`: 매개 변수 여러개를 받아 적합한 타입의 인스턴스 반환
- `valueOf`: from과 of의 더 자세한 버전
- `instance` or `getInstance`: 같은 인스턴스임을 보장하진 않음
- `create` or `newInstance`: 매번 새로운 인스턴스임을 보장
- `getType`: 구현된 클래스 본인이 아닌, 다른 클래스의 인스턴스를 반환
- `newType`: newInstance + getType 특징을 가짐
- `type`: getType, newType 의 간결 버전

### 핵심 정리

- 반드시 쓰라는게 아니고 장단점을 파악해 쓰자
- 무작정 public 생성자 보단 정적 팩터리 메서드를 고려하는 습관을 가져보자